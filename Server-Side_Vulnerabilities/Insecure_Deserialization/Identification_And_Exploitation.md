<h1>Identify Insecure Deserialization</h1>

During testing, analyze all data that is passed in requests with the server and look for data that is <mark>serialized</mark>

<h2>PHP Serialization Format</h2>

PHP uses a mostly human-readable string format, with letters representing the data type and numbers representing the length of each entry. For example, consider a User object with the attributes:

```
$user->name = "carlos";
$user->isLoggedIn = true;
```

When serialized, the above data may look like this:

```
O:4:"User":2:{s:4:"name":s:6:"carlos";s:10:"isLoggedIn":b:1;}
```

<ul>
  <li>O:4:"User" - An object with the 4-character class name "User"</li>
  <li>2 - the object has 2 attributes</li>
  <li>s:4:"name" - The key of the first attribute is the 4-character string "name"</li>
  <li>s:6:"carlos" - The value of the first attribute is the 6-character string "carlos"</li>
  <li>s:10:"isLoggedIn" - The key of the second attribute is the 10-character string "isLoggedIn"</li>
  <li>b:1 - The value of the second attribute is the boolean value true</li>
</ul>

The native methods for PHP serialization are <mark>serialize()</mark> and <mark>unserialize()</mark>. If you have source code access, you should start by looking for unserialize() anywhere in the code and investigating further.

<h2>Java Serialization Format</h2>

Some languages, such as Java, use binary serialization formats. This is more difficult to read, but you can still identify serialized data if you know how to recognize a few tell-tale signs. For example, serialized Java objects 
always begin with the same bytes, which are encoded as ac ed in hexadecimal and rO0 in Base64. Any class that implements the interface java.io.Serializable can be serialized and deserialized. If you have source code access, take
note of any code that uses the <mark>readObject()</mark> method, which is used to read and deserialize data from an InputStream.


<h1>Exploitation Of Insecure Deserialization</h1>

<h2>Manipulation Of Object Attributes</h2>

Exploiting some deserialization vulnerabilities can be as easy as changing an attribute in a serialized object. As the object state is persisted, you can study the serialized data to identify and edit interesting attribute values. 
You can then pass the malicious object into the website via its deserialization process. This is the initial step for a basic deserialization exploit.

You can either: 

1. edit the object directly in its byte stream form
2. or you can write a short script in the corresponding language to create and serialize the new object yourself.

The latter approach is often easier when working with binary serialization formats.

<h2>Modifying Object Attributes</h2>

When tampering with the data, as long as the attacker preserves a valid serialized object, the deserialization process will create a server-side object with the modified attribute values

Example(s)

<b>Scenario</b>: website that uses a serialized User object to store data about a user's session in a cookie. Admin functionality is restricted to Admins only. All other requests should be denied with a 401 request.
The decoded, serialized data might look like this:

```
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```

The <mark>isAdmin</mark> attribute is a huge point of interest that could potentially lead to priviledge escalation. An attacker could simply change the boolean value of 0 to 1, re-encode the 
object and then use this session cookie when trying to access data that is restricted to admin access only. See the images below.

![insecure-deserialization-priv-esc-admin-portal-401-response](https://github.com/user-attachments/assets/1473c006-2421-4741-b429-1edffdbe36f8)

![insecure-deserialization-priv-esc-admin-portal-200-response](https://github.com/user-attachments/assets/2608d7ef-8279-4072-bf0d-c446a6b710b5)


<b>Scenario</b>: Website uses a serialized User object to store data about a user's session in a cookie. We want to impersonate the administrator access_token in order to access admin functionality.
Admin functionality is restricted to Admins only. All other requests should be denied with a 401 request. The decoded, serialized data might look like this:

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"w1h4v2rtl7xvdn2pj5gn4smskc0adqqx";}
```

We can try to manipulate the access_token object by passing a boolean value that evaluates to true when deserialized:

```
O:4:"User":2:{s:8:"username";s:13:"administrator";s:12:"access_token";b:1;}
```

See images below

<img width="1859" height="650" alt="insecure-deserialization-priv-esc-access-token-object-manipulation-401-response" src="https://github.com/user-attachments/assets/3bbacf0e-cec9-4657-b04d-6846c180a749" />

<img width="1860" height="615" alt="insecure-deserialization-priv-esc-access-token-object-manipulation-200-response" src="https://github.com/user-attachments/assets/85a0f209-de10-4df3-a476-cf9b36937b92" />




