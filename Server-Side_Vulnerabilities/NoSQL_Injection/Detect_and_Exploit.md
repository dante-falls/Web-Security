<h1>How The Heck Do I Detect NoSQL Injection? - FOR EDUCATIONAL PURPOSES ONLY</h1>

<h2>Attempt To Cause A Database Error</h2>
Try to cause a database error by injecting database specific strings that will cause errors.

```'"`{
;$Foo}
$Foo \xYZ```

URL Encoded: ```%27%22%60%7b%0d%0a%3b%24%46%6f%6f%7d%0d%0a%24%46%6f%6f%20%5c%78%59%5a```

JSON SAFE: ```'\"`{\r;$Foo}\n$Foo \\xYZ\u0000```

<h2>Determine Which Characters Break The Query</h2>

If the ' symbol breaks the query, try to escape it and see if the server still serves an error. If escaping the symbol fixes the backend query, the application is likely vulnerable to NoSQL Injection. Analyze
the images below to see this.

<mark>Injecting a ' symbol</mark>

<img width="1909" height="699" alt="detect-which-character-breaks-query" src="https://github.com/user-attachments/assets/a6ae4b0f-92b1-4065-8696-17261b864473" />

<mark>Escaping the ' symbol to fix the backend MongoDB query</mark>

<img width="1910" height="696" alt="fix-query-by-escaping-quote-symbol" src="https://github.com/user-attachments/assets/2307c91f-cdc7-42b7-a81c-1b54358c6561" />


<h2>Detecting NoSQL Syntax Injection - FOR EDUCATIONAL PURPOSES ONLY</h2>

Lets assume the backend MongoDB query is this.category=='' and the injection point is the 'category=' parameter

Injecting a single ' character make the backend MongoDB query into this.category==''' and will break the database query. Analyze the image below

<img width="1909" height="699" alt="detect-which-character-breaks-query" src="https://github.com/user-attachments/assets/e48fd37c-8187-495a-ac75-3c4e305318f2" />


Now that we know we can inject into the MongoDB query, let's inject a conditional at the end of the query to confirm all input is unsanitized.

Our payload will be: Lifestyle'+%26%26+this.category[0]=='L

This will make the MongoDB query look like: this.category=='Lifestyle' && this.category[0]=='L'

If this fixes the query and makes the server return data from the Lifestyle category, then the application is vulnerable.

Analyze the image below to see this

<img width="1911" height="695" alt="injecting-conditional-into-nosql-query" src="https://github.com/user-attachments/assets/0c1b95c3-9fbf-4f97-80e1-926326064550" />

<h1>Exploiting NoSQL Syntax Injection - FOR EDUCATIONAL PURPOSES ONLY</h1>

<h3>Injecting A Conditional With A Null Character To Query Unauthorized Data</h3>

Because we can inject a conditional statement and ending the query with a null character, we can view data we are not authorized to view, like unreleased products in our case.
By ending the query in a null character, the MongoDB does not read the rest of the query where the developers attempted to only serve products that are released.

We simply inject: category=Lifestyle'+||+'1'=='1'%00 

which results in a backend query of: this.category=='Lifestyle' || '1'=='1'%00

Analyze the image below where we make the backend MongoDB serve us all products including unreleased products

<img width="1905" height="698" alt="conditional-with-null-character-to-show-unauthorized-data" src="https://github.com/user-attachments/assets/0078054c-672d-4979-8dca-35e31672e0d7" />

<h1>Exploiting NoSQL operator injection - FOR EDUCATIONAL PURPOSES ONLY</h1>

NoSQL databases often use query operators, which provide ways to specify conditions that data must meet to be included in the query result.

<table border="1">
  <tr>
    <th>Operator</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>$where</td>
    <td>Matches documents that satisfy a JavaScript expression</td>
  </tr>
  <tr>
    <td>$ne</td>
    <td>Matches all values that are not equal to a specified value</td>
  </tr>
  <tr>
    <td>$in</td>
    <td>Matches all of the values specified in an array</td>
  </tr>
  <tr>
    <td>$regex</td>
    <td>Selects documents where values match a specified regular expression</td>
  </tr>
  <tr>
    <td>$gt</td>
    <td>greater than</td>
  </tr>
  <tr>
    <td>$lt</td>
    <td>less then</td>
  </tr>
  <tr>
    <td>$nin</td>
    <td>not in</td>
  </tr>
</table>

<h2>Submitting query operators</h3>
<h3>JSON Messaes</h3>
In JSON messages, you can insert query operators as nested objects. For example, {"username":"wiener"} becomes {"username":{"$ne":"invalid"}}.

<h3>URL-Based Input</h3>
For URL-based inputs, you can insert query operators via URL parameters. For example, username=wiener becomes username[$ne]=invalid. If this doesn't work, you can try the following:

<h3>Also Try...</h3>

1. Convert the request method from GET to POST (or PUT or PATCH).
2. Change the Content-Type header to application/json.
3. Add JSON to the message body.
4. Inject query operators in the JSON.


<h2>Bypassing Authentication With NoSQL Operator Injection - FOR EDUCATIONAL PURPOSES ONLY</h2>

<h3>When You Know A Valid Username</h3>
If we know a valid username, we can use the $ne operator to bypass authentication and login as that user. For example: {"username":"wiener",password:{"$ne":"invalid"}}

Analyze the image below where we inject the $ne operator to bypass authentication and login as the user 'wiener'

<img width="1906" height="696" alt="ne-operator-bypass-authentication-nosql" src="https://github.com/user-attachments/assets/ef77757e-b8f1-4cdb-a1d5-c1ccbadd625d" />

<h3>When You Dont Know A Valid Username</h3>
If we don't know a valid username, we can use the $regex operator to query with partial usernames. For example: {"username":{"regex":"admi.*"},"password":{"$ne":"invalid"}}

Analyze the images below where we utilize the $ne and $regex operators to bypass authentication and gain access to the administrator account within our Portswigger Lab Instance

<img width="1912" height="834" alt="json-login-invalid-admin-credentials" src="https://github.com/user-attachments/assets/c7fc75dc-982e-4dad-b86d-da56560c1300" />

<img width="1908" height="703" alt="json-login-valid-admin-credentials-with-operator-injection" src="https://github.com/user-attachments/assets/e4de3cab-2e9d-4580-bdf2-b0f641a32aec" />



<h1>Time-Based NoSQL Injection - FOR EDUCATIONAL PURPOSES ONLY</h1>

Sometimes triggering a database error doesn't cause a difference in the application's response. In this situation, you may still be able to detect and exploit the vulnerability by using JavaScript injection to trigger a conditional time delay.

To conduct Timing-Based NoSQL Injection:

1. Load the page several times to determine a baseline loading time.
2. Insert a timing based payload into the input. A timing based payload causes an intentional delay in the response when executed. For example, ```{"$where": "sleep(5000)"}``` causes an intentional delay of 5000 ms on successful injection.
3. Identify a difference in the timing of the server's response. This indicates a successful injection.

Analyze the below image where I make the server delay for 15 seconds. I injected a 5000 millisecond delay payload:

https://0a06001d03e8819980c621e6008d0088.web-security-academy.net/user/lookup?user='||sleep(5000)%00

```
'||sleep(5000)%00
```

<img width="1909" height="704" alt="time-based-nosql-example-educational-purposes-only" src="https://github.com/user-attachments/assets/8ddef44c-75e2-46ed-a4c0-5a1016c9e4aa" />






